//Kruskal code with cycle detection by using Union by rank method

#include<bits/stdc++.h>
typedef long long ll;
using namespace std;

class Edge{
public:
	int src;
	int dest;
	int weight;
};

class Set{
public:
	int rank;
	int parent;
};

//find function returns the parent to which a particular
//'i' belongs to
int find(Set *set,int i){
	if(set[i].parent!=i){
		set[i].parent = find(set,set[i].parent);
	}
	return set[i].parent;
}
void Union(Set *set,int v1,int v2){
	int v1_root = find(set,v1);
	int v2_root = find(set,v2);
	if(set[v1_root].rank < set[v2_root].rank){
		set[v1_root].parent=v2_root;
	}
	else if(set[v1_root].rank > set[v2_root].rank){
		set[v2_root].parent=v1_root;
	}
	else{
		set[v2_root].parent=v1_root;
		set[v1_root].rank++;
	}
}

bool cmp(Edge e1,Edge e2){
	return e1.weight<e2.weight;
}

void Kruskal(Edge *input,int n,int e){
	sort(input,input+e,cmp);
	//as we know our spanning tree will contain n-1 edges 
	//corresponding to n vertices
	Edge *output = new Edge[n-1];
	Set *set = new Set[n];
	for(int i=0;i<n;i++){
		set[i].rank=0;
		set[i].parent=i;
	}
	int counter=0,i=0;
	while(counter<n-1){
		Edge currentEdge = input[i];
		int sourceParent = find(set,currentEdge.src);
		int destinationParent = find(set,currentEdge.dest);
		if(sourceParent != destinationParent){
			//inserting this edge in mst will not give us cycle as they
			//both lie in different set
			output[counter]=currentEdge;
			//we will union source and destination vertex
			Union(set,sourceParent,destinationParent);
			counter++;
		}
		i++;
	}
	for(int m=0;m<n-1;m++){
		cout<<output[m].src<<"--"<<output[m].dest<<" with weight "<<output[m].weight<<"\n";
	}
}

int main(){
	//g++ -o kruskal kruskal.cpp&kruskal.exe
	int n,e;
	cin>>n>>e;
	Edge *input = new Edge[e];
	for(int i=0;i<e;i++){
		int s,d,w;
		cin>>s>>d>>w;
		input[i].src = s;
		input[i].dest = d;
		input[i].weight = w;
	}
	Kruskal(input,n,e);
	return 0;
}